Index: src/lab6/server/ServerService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package lab6.server;\r\n\r\nimport lab6.Serializer;\r\nimport lab6.commands.Command;\r\nimport lab6.exceptions.collection_exceptions.CollectionException;\r\nimport lab6.exceptions.collection_exceptions.SaveCollectionException;\r\nimport lab6.exceptions.file_exceptions.CannotCreateFileException;\r\nimport lab6.exceptions.file_exceptions.FileAlreadyExistsException;\r\nimport lab6.exceptions.file_exceptions.FilePermissionException;\r\nimport lab6.exceptions.file_exceptions.InvalidFileNameException;\r\nimport lab6.request_response.*;\r\n\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.net.*;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.LinkedList;\r\n\r\npublic class ServerService {\r\n    public static final int PORT = 5432;\r\n\r\n    private static ByteBuffer buffer = ByteBuffer.allocate(1024);\r\n    private static byte[] bytes = new byte[1024];\r\n    private static DatagramSocket socket = null;\r\n    private static DatagramPacket packet = null;\r\n    private static InetAddress clientAddress;\r\n    private static int clientPort;\r\n    private static InetSocketAddress clientSocketAddress;\r\n    private static boolean connectionEstablished = false;\r\n\r\n    private static Application application;\r\n\r\n    public static void main() {\r\n        while (true) {\r\n            runServerMainLoop();\r\n            resetConnection();\r\n        }\r\n\r\n    }\r\n\r\n    private static void runServerMainLoop() {\r\n        boolean isRunning = true;\r\n        try {\r\n            startServer();\r\n            establishConnection();\r\n\r\n            application = new Application();\r\n\r\n            while (isRunning) {\r\n                receiveRequest(); // todo: execute command\r\n                Request request = (Request) Serializer.deserialize(extractBuffer(buffer));\r\n                if (request.getType() == RequestType.LOAD) {\r\n                    String fileName = (String) request.getArgs()[0];\r\n                    loadFile(fileName);\r\n                    continue;\r\n                }\r\n                if (request.getType() == RequestType.CREATE) {\r\n                    String fileName = (String) request.getArgs()[0];\r\n                    createFile(fileName);\r\n                    continue;\r\n                }\r\n                if (request.getType() == RequestType.EXECUTE) {\r\n                    Command command = request.getCommand();\r\n                    Object[] cmdArgs = request.getArgs();\r\n                    executeCommand(command, cmdArgs);\r\n                    continue;\r\n                }\r\n\r\n                if (request.getType() == RequestType.EXIT) {\r\n                    boolean savedSuccessfully = exit();\r\n                    if (savedSuccessfully) {\r\n                        isRunning = false;\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /*______________________________________________________________________________________________________________*/\r\n    /*                                     Client's requests methods                                                */\r\n\r\n    private static boolean exit() throws IOException {\r\n        try {\r\n            LinkedList<String> runtimeMessages = application.saveCollection();\r\n            String exitMessage = runtimeMessages.pollLast();\r\n            Response response = new Response(ResponseType.SUCCESS, exitMessage, runtimeMessages);\r\n            sendResponse(response);\r\n            return true;\r\n        } catch (FilePermissionException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.PERMISSION_DENIED);\r\n            sendResponse(response);\r\n        } catch (InvalidFileNameException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.INVALID_FILE_NAME);\r\n            sendResponse(response);\r\n        } catch (SaveCollectionException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.EXECUTE_COMMAND_EXCEPTION);\r\n            sendResponse(response);\r\n        } catch (FileNotFoundException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.FILE_NOT_FOUND);\r\n            sendResponse(response);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private static void executeCommand(Command command, Object[] cmdArgs) throws IOException {\r\n        try {\r\n            String exitMessage = application.executeCommand(command, cmdArgs);\r\n            Response response = new Response(ResponseType.SUCCESS, exitMessage);\r\n            sendResponse(response);\r\n        } catch (CollectionException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.EXECUTE_COMMAND_EXCEPTION);\r\n            sendResponse(response);\r\n        }\r\n    }\r\n\r\n    private static void loadFile(String fileName) throws IOException {\r\n        try {\r\n            LinkedList<String> runtimeMessages = application.loadCollection(fileName);\r\n            String exitMessage = runtimeMessages.pollLast();\r\n            Response response = new Response(ResponseType.SUCCESS, exitMessage, runtimeMessages);\r\n            sendResponse(response);\r\n        } catch (FileNotFoundException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.FILE_NOT_FOUND);\r\n            sendResponse(response);\r\n        } catch (FilePermissionException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.PERMISSION_DENIED);\r\n            sendResponse(response);\r\n        } catch (InvalidFileNameException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.INVALID_FILE_NAME);\r\n            sendResponse(response);\r\n        }\r\n    }\r\n\r\n    private static void createFile(String fileName) throws IOException {\r\n        try {\r\n            String exitMessage = application.createBlankFile(fileName);\r\n            Response response = new Response(ResponseType.SUCCESS, exitMessage);\r\n            sendResponse(response);\r\n        } catch (FilePermissionException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.PERMISSION_DENIED);\r\n            sendResponse(response);\r\n        } catch (FileAlreadyExistsException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.FILE_ALREADY_EXISTS);\r\n            sendResponse(response);\r\n        } catch (CannotCreateFileException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.CANNOT_CREATE_FILE);\r\n            sendResponse(response);\r\n        } catch (InvalidFileNameException e) {\r\n            Response response = new Response(ResponseType.ERROR, e.getMessage(), ExceptionType.INVALID_FILE_NAME);\r\n            sendResponse(response);\r\n        }\r\n    }\r\n\r\n    /*______________________________________________________________________________________________________________*/\r\n\r\n\r\n    /*______________________________________________________________________________________________________________*/\r\n    /*                                     Initialize server service methods                                        */\r\n\r\n    private static void startServer() throws IOException {\r\n        socket = new DatagramSocket(PORT);\r\n        packet = new DatagramPacket(bytes, bytes.length);\r\n    }\r\n\r\n    private static void establishConnection() throws IOException {\r\n        if (socket == null || packet == null) throw new SocketException(\"Socket and/or packet has not been initialised yet\");\r\n        socket.receive(packet);\r\n        clientAddress = packet.getAddress();\r\n        clientPort = packet.getPort();\r\n        clientSocketAddress = new InetSocketAddress(clientAddress, clientPort);\r\n        sendResponse(new Response(ResponseType.SUCCESS, \"Connection established\"));\r\n        connectionEstablished = true;\r\n    }\r\n\r\n    /*______________________________________________________________________________________________________________*/\r\n\r\n    private static void receiveRequest() throws IOException {\r\n        if (socket == null || packet == null) throw new SocketException(\"Socket and/or packet has not been initialised yet\");\r\n        if (!connectionEstablished) throw new SocketException(\"Connection has not been established yet\");\r\n        socket.receive(packet);\r\n        buffer.clear();\r\n        buffer.put(packet.getData());\r\n    }\r\n\r\n    private static void sendResponse(Response response) throws IOException {\r\n        bytes = Serializer.serialize(response);\r\n        packet = new DatagramPacket(bytes, bytes.length, clientSocketAddress);\r\n        socket.send(packet);\r\n    }\r\n\r\n    private static byte[] extractBuffer(ByteBuffer buffer) {\r\n        buffer.flip();\r\n        byte[] bytes = new byte[buffer.remaining()];\r\n        buffer.get(bytes);\r\n        buffer.flip();\r\n        return bytes;\r\n    }\r\n\r\n    private static void resetConnection() {\r\n        buffer.clear();\r\n        packet = null;\r\n        clientAddress = null;\r\n        clientPort = -1;\r\n        clientSocketAddress = null;\r\n        connectionEstablished = false;\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/lab6/server/ServerService.java b/src/lab6/server/ServerService.java
--- a/src/lab6/server/ServerService.java	(revision b1b773466c4d21e308fc8887ac7f6f4ac6238bce)
+++ b/src/lab6/server/ServerService.java	(date 1650922090722)
@@ -10,8 +10,10 @@
 import lab6.exceptions.file_exceptions.InvalidFileNameException;
 import lab6.request_response.*;
 
+import java.io.ByteArrayInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.ObjectInputStream;
 import java.net.*;
 import java.nio.ByteBuffer;
 import java.util.LinkedList;
@@ -176,12 +178,14 @@
 
     /*______________________________________________________________________________________________________________*/
 
-    private static void receiveRequest() throws IOException {
+    private static Request receiveRequest() throws IOException, ClassNotFoundException {
         if (socket == null || packet == null) throw new SocketException("Socket and/or packet has not been initialised yet");
         if (!connectionEstablished) throw new SocketException("Connection has not been established yet");
+        byte[] bytes = new byte[4096];
+        DatagramPacket packet = new DatagramPacket(bytes, bytes.length);
         socket.receive(packet);
-        buffer.clear();
-        buffer.put(packet.getData());
+        ObjectInputStream bytesToRequestStream = new ObjectInputStream(new ByteArrayInputStream(packet.getData()));
+        return (Request) bytesToRequestStream.readObject();
     }
 
     private static void sendResponse(Response response) throws IOException {
Index: src/lab6/client/ConsoleManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package lab6.client;\r\n\r\nimport lab6.IO.IOManager;\r\nimport lab6.collection.MovieBuilder;\r\nimport lab6.exceptions.factory_exceptions.FactoryException;\r\nimport lab6.request_response.Request;\r\nimport lab6.request_response.RequestType;\r\nimport lab6.request_response.Response;\r\nimport lab6.server.Application;\r\nimport lab6.commands.*;\r\nimport lab6.exceptions.collection_exceptions.CollectionException;\r\nimport lab6.exceptions.collection_exceptions.RecursionException;\r\nimport lab6.exceptions.factory_exceptions.CannotAccessCommandException;\r\nimport lab6.exceptions.factory_exceptions.CommandNotFoundException;\r\nimport lab6.exceptions.file_exceptions.FileException;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.*;\r\n\r\n/**\r\n * Connects IO with application.\r\n * Also generates new commands by user's input.\r\n * Static block loads all available commands to the class loader\r\n * and saves their descriptions to the sorted linked hash map.\r\n */\r\npublic class ConsoleManager {\r\n\r\n//    private Application application;\r\n    private IOManager ioManager;\r\n    private MovieBuilder movieBuilder;\r\n\r\n\r\n    /* Contains all commands' description */\r\n    private final static LinkedHashMap<String, String> descriptionsMap;\r\n\r\n    private String[] commandsWithMovieArg = new String[] {\"add\", \"add_if_max\", \"update\"};\r\n\r\n\r\n    static {\r\n        /* Registering all available commands */\r\n        try {\r\n            CommandsFactory.registerCommand(\"add\", AddCommand.class);\r\n            CommandsFactory.registerCommand(\"clear\", ClearCommand.class);\r\n            CommandsFactory.registerCommand(\"add\", AddCommand.class);\r\n            CommandsFactory.registerCommand(\"add_if_max\", AddIfMaxCommand.class);\r\n            CommandsFactory.registerCommand(\"clear\", ClearCommand.class);\r\n            CommandsFactory.registerCommand(\"count_less_than_oscars_count\", CountLessThanOscarsCountCommand.class);\r\n            CommandsFactory.registerCommand(\"filter_starts_with_tagline\", FilterStartsWithTaglineCommand.class);\r\n            CommandsFactory.registerCommand(\"info\", InfoCommand.class);\r\n            CommandsFactory.registerCommand(\"max_by_screenwriter\", MaxByScreenwriterCommand.class);\r\n            CommandsFactory.registerCommand(\"remove_by_id\", RemoveByIdCommand.class);\r\n            CommandsFactory.registerCommand(\"remove_head\", RemoveHeadCommand.class);\r\n            CommandsFactory.registerCommand(\"remove_lower\", RemoveLowerCommand.class);\r\n//            CommandsFactory.registerCommand(\"save\", SaveCommand.class);\r\n            CommandsFactory.registerCommand(\"show\", ShowCommand.class);\r\n            CommandsFactory.registerCommand(\"update\", UpdateCommand.class);\r\n        } catch (CommandNotFoundException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        /* Collecting all available commands' descriptions */\r\n        HashMap<String, String> unsortedDescriptionsMap = new HashMap<>();\r\n        unsortedDescriptionsMap.put(\"help\", \"HELP ... provides help\");\r\n        unsortedDescriptionsMap.put(\"exit\", \"EXIT ... saves collection and closes program\");\r\n        for (String tag : CommandsFactory.getAllRegisteredTags()) {\r\n            try {\r\n                unsortedDescriptionsMap.put(tag, CommandsFactory.getDescription(tag));\r\n            } catch (CommandNotFoundException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        descriptionsMap = HashMapSorter.sortHashMap(unsortedDescriptionsMap);\r\n\r\n    }\r\n\r\n\r\n    public ConsoleManager(IOManager ioManager) {\r\n        this.ioManager = ioManager;\r\n        this.movieBuilder = new MovieBuilder(ioManager);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Method that begins Console Manager iteration.\r\n     */\r\n    public Request execute() throws FactoryException {\r\n        String input;\r\n        LinkedList<String> parsedInput = new LinkedList<>();\r\n        String commandTag;\r\n\r\n        input = ioManager.getNextInput(\"Type command (type \\\"help\\\" for help): \").toLowerCase(Locale.ROOT);\r\n\r\n        for (String word : input.split(\"\\\\s+\")) {\r\n            parsedInput.add(word.trim());\r\n        }\r\n\r\n        if (parsedInput.size() == 0) {\r\n            return null;\r\n        }\r\n\r\n        commandTag = parsedInput.pollFirst();\r\n\r\n        switch (commandTag) {\r\n\r\n            case (\"help\"):\r\n                for (String cmdDescription : descriptionsMap.values()) {\r\n                    ioManager.printlnInfoFormat(cmdDescription.split(\"\\\\.\\\\.\\\\.\"));\r\n                }\r\n                return null;\r\n\r\n            case (\"exit\"):\r\n                return new Request(RequestType.EXIT);\r\n\r\n            case (\"execute_script\"):\r\n                if (parsedInput.size() == 1) {\r\n                    ioManager.printlnErr(\"Cannot execute script because file name wasn't specified\");\r\n                    continue;\r\n                }\r\n                ioManager.printlnStatus(\"Executing script...\");\r\n                HashSet scriptsCallStack = new HashSet();\r\n                scriptsCallStack.add(parsedInput.get(1));\r\n                try {\r\n                    boolean recursionExitCode = executeScript(parsedInput.get(1), new HashSet<>());\r\n                    if (!recursionExitCode) {\r\n                        ioManager.printlnStatus(\"Terminating program...\");\r\n                        ioManager.clearScannerStack();\r\n                        return;\r\n                    }\r\n                    ioManager.clearScannerStack();\r\n                    break;\r\n                } catch (FileException | RecursionException | IOException e) {\r\n                    ioManager.clearScannerStack();\r\n                    ioManager.printlnErr(e.getMessage());\r\n                    break;\r\n                }\r\n\r\n            default:\r\n                Command command = CommandsFactory.getCommand(commandTag);\r\n                String[] commandArgs = new String[parsedInput.size()];\r\n                for (String arg : parsedInput) {\r\n                    commandArgs[parsedInput.indexOf(arg)] = arg.trim();\r\n                }\r\n                return new Request(RequestType.EXECUTE, command, commandArgs);\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Method that executes scripts from file.\r\n     *\r\n     * @param fileName              Name of the file contains script to execute\r\n     * @param stackTrace            Stack of file names that already have been called\r\n     * @return                      \"true\" if program must terminate after executing script (if there was \"exit\" command in the script)\r\n     * @throws FileException        Exception thrown if program could not access specified script file\r\n     * @throws IOException          Exception thrown if IO manager had caught incorrect input\r\n     * @throws RecursionException   Exception thrown if recursion had been found\r\n     */\r\n    public boolean executeScript(String fileName, HashSet<String> stackTrace) throws FileException, IOException, RecursionException {\r\n        if (stackTrace.contains(fileName)) {\r\n            throw new RecursionException(\"Recursion has been found\");\r\n        }\r\n        File file = application.getFileManager().openFile(fileName);\r\n        stackTrace.add(fileName);\r\n        Scanner fileScanner = new Scanner(file).useDelimiter(\"\\n\");\r\n        ioManager.pushScanner(fileScanner);\r\n        String input;\r\n        String[] parsedInput;\r\n\r\n        while (fileScanner.hasNextLine()) {\r\n\r\n            input = fileScanner.nextLine();\r\n            ioManager.printlnStatus(\">>> \" + input);\r\n            parsedInput = input.split(\"\\\\s+\");\r\n\r\n            if (parsedInput.length == 0) {\r\n                continue;\r\n            }\r\n\r\n            String commandTag = parsedInput[0].trim();\r\n\r\n            switch (commandTag) {\r\n\r\n                case (\"help\"):\r\n                    for (String cmdDescription : descriptionsMap.values()) {\r\n                        ioManager.printlnInfoFormat(cmdDescription.split(\"\\\\.\\\\.\\\\.\"));\r\n                    }\r\n                    break;\r\n\r\n                case (\"exit\"):\r\n                    return false;\r\n\r\n                case (\"execute_script\"):\r\n                    if (parsedInput.length == 1) {\r\n                        ioManager.printlnErr(\"Script file name wasn't specified\");\r\n                        continue;\r\n                    }\r\n                    ioManager.printlnStatus(\"Executing script...\");\r\n                    boolean statusCode = executeScript(parsedInput[1], stackTrace);\r\n                    if (!statusCode) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    try {\r\n                        Command command = CommandsFactory.getCommand(commandTag, application.getMoviesCollection());\r\n                        String[] commandArgs = Arrays.copyOfRange(parsedInput, 1, parsedInput.length);\r\n                        for (int i = 0; i < commandArgs.length; i++) {\r\n                            commandArgs[i] = commandArgs[i].trim();\r\n                        }\r\n                        ioManager.printlnSuccess(\r\n                                application.executeCommand(command, commandArgs)\r\n                        );\r\n                    } catch (CommandNotFoundException | CannotAccessCommandException | CollectionException e) {\r\n                        ioManager.printlnErr(e.getMessage());\r\n                    }\r\n                    break;\r\n            }\r\n\r\n        }\r\n        ioManager.popScanner();\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/lab6/client/ConsoleManager.java b/src/lab6/client/ConsoleManager.java
--- a/src/lab6/client/ConsoleManager.java	(revision b1b773466c4d21e308fc8887ac7f6f4ac6238bce)
+++ b/src/lab6/client/ConsoleManager.java	(date 1650922471202)
@@ -26,15 +26,16 @@
  */
 public class ConsoleManager {
 
-//    private Application application;
+    //    private Application application;
     private IOManager ioManager;
     private MovieBuilder movieBuilder;
+    private Cli
 
 
     /* Contains all commands' description */
     private final static LinkedHashMap<String, String> descriptionsMap;
 
-    private String[] commandsWithMovieArg = new String[] {"add", "add_if_max", "update"};
+    private String[] commandsWithMovieArg = new String[]{"add", "add_if_max", "update"};
 
 
     static {
@@ -81,7 +82,6 @@
     }
 
 
-
     /**
      * Method that begins Console Manager iteration.
      */
@@ -114,10 +114,11 @@
                 return new Request(RequestType.EXIT);
 
             case ("execute_script"):
+                return null;
                 if (parsedInput.size() == 1) {
-                    ioManager.printlnErr("Cannot execute script because file name wasn't specified");
-                    continue;
-                }
+
+                }
+                ioManager.printlnErr("Cannot execute script because file name wasn't specified");
                 ioManager.printlnStatus("Executing script...");
                 HashSet scriptsCallStack = new HashSet();
                 scriptsCallStack.add(parsedInput.get(1));
@@ -143,9 +144,10 @@
                     commandArgs[parsedInput.indexOf(arg)] = arg.trim();
                 }
                 return new Request(RequestType.EXECUTE, command, commandArgs);
-
-
-
+        }
+        return null;
+    }
+}
 
     /**
      * Method that executes scripts from file.
@@ -161,7 +163,7 @@
         if (stackTrace.contains(fileName)) {
             throw new RecursionException("Recursion has been found");
         }
-        File file = application.getFileManager().openFile(fileName);
+        File file = .openFile(fileName);
         stackTrace.add(fileName);
         Scanner fileScanner = new Scanner(file).useDelimiter("\n");
         ioManager.pushScanner(fileScanner);
